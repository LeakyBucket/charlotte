{"name":"Charlotte","tagline":"Elixir Web Framework","body":"## What?\r\n\r\nCharlotte is a Web Framework written in Elixir.  It takes after\r\nboth Rails and Sinatra in some ways.  In other ways Charlotte is\r\na different animal entirely.\r\n\r\n## Why?\r\n\r\nThat's a good question.  When I first started playing with Elixir\r\nthere weren't a ton of frameworks out there.  I decided that as\r\npart of learning the language I'd build one.\r\n\r\n## Short How\r\n\r\nThe quickest way to get started is to add Charlotte as a dependency\r\nto your project.\r\n\r\n```elixir\r\n  { :charlotte, \"~> 0.3.0\" }\r\n```\r\n\r\nOnce you have added and installed the dependency you are good to go.\r\n\r\nThere are a few different environment variables that Charlotte\r\nexpects.  These can be set outside the application or defaults\r\ncan be given to Charlotte.start/2\r\n\r\n```elixir\r\n  default_config = HashDict.new\r\n\r\n  Charlotte.start [], [default_config: build_config(default_config)]\r\n\r\n  def build_config(default_config) do\r\n    default_config |>\r\n      HashDict.put(\"CHARLOTTE_CONTROLLER_PATH\", __DIR__ <> \"/support/controllers\") |>\r\n      HashDict.put(\"CHARLOTTE_VIEW_PATH\", __DIR__ <> \"/support/views\") |>\r\n      HashDict.put(\"CHARLOTTE_ASSET_PATH\", __DIR__ <> \"/support/assets\") |>\r\n      HashDict.put(\"CHARLOTTE_HOST\", \"localhost\") |>\r\n      HashDict.put(\"CHARLOTTE_PROTOCOL\", \"tcp\") |>\r\n      HashDict.put(\"CHARLOTTE_ACCEPTORS\", \"100\") |>\r\n      HashDict.put(\"CHARLOTTE_COMPRESS\", \"false\") |>\r\n      HashDict.put(\"CHARLOTTE_PORT\", \"8000\")\r\n  end\r\n```\r\n\r\n## Long How\r\n\r\n### Routes  \r\n\r\nRouting in Charlotte is a bit different than most other frameworks.\r\nRoutes are actually a concern of the controller.  \r\n\r\n```elixir\r\n  defmodule MyController do\r\n    use Charlotte.Handlers.HTTP\r\n\r\n    def routes do\r\n      [\r\n        {\"/\", :root}\r\n      ]\r\n    end\r\n\r\n    def root(verb, params, conn) do\r\n      ...\r\n    end\r\n  end\r\n```\r\n\r\nEach controller defines the routes that it is responsible for.\r\nCharlotte expects this to be in the form of a list of `{path, action}`\r\ntuples.  The path should be a binary/string with the actual path\r\nthat should be matched.  \r\n\r\nYou can provide [Cowboy-style bindings](http://ninenines.eu/docs/en/cowboy/HEAD/guide/routing/)\r\nin this path declaration.  \r\n\r\n```elixir\r\n  def routes do\r\n    [\r\n      {\"/\", :root},\r\n      {\"/path/with/:variable\", :variable_path}\r\n    ]\r\n  end\r\n```\r\n\r\nThese bindings will be present in the parameters passed to the\r\naction. In the example above a request to `/path/with/value`\r\nwould be handled by the `variable_path` action and in that\r\naction `params[:variable]` would return `\"value\"`.\r\n\r\nThe action should always be an atom\r\nwith the same name as the function to be called when that path is\r\nrequested.  That function is assumed to exist in the module that\r\ndefines the route.  \r\n\r\n### Controllers\r\n\r\n#### Organization\r\n\r\nA Charlotte controller is simply a module that exists in the\r\nCHARLOTTE_CONTROLLER_PATH directory.  \r\n\r\n```\r\n  # Assuming CHARLOTTE_CONTROLLER_PATH environment var is set to \"/var/www/app/controllers\"\r\n\r\n  $ ls /var/www/app/controllers\r\n    users.ex\r\n    fees.ex\r\n    locations.ex\r\n```\r\n\r\nIn the above example Charlotte would assume users.ex, fees.ex and\r\nlocations.ex define controller modules.  \r\n\r\n#### Content\r\n\r\nIn order for a controller module to be useful for Charlotte it\r\nneeds to do the following:  \r\n\r\n* Implement a routes function as described above\r\n* Implement the appropriate Cowboy callbacks for the protocol it supports\r\n* Handle view rendering and formatting and sending the response to the client  \r\n\r\nIt is possible to implement the last two requirements yourself or\r\nyou can simply use the appropriate Charlotte Handler.  \r\n\r\n```elixir\r\n  defmodule MyController do\r\n    use Charlotte.Handlers.HTTP\r\n\r\n    ...\r\n  end\r\n```\r\n\r\nThe HTTP Handler will define the required callbacks for HTTP 1.1\r\nin Cowboy as well as a few helpers for generating a response:\r\nrender/3 redirect/2 forbidden/1  \r\n\r\n#### Responding  \r\n\r\nThe render function takes 3 arguments:  \r\n\r\n* status\r\n* bindings\r\n* conn\r\n\r\nThe status is the integer status code that should accompany the\r\nresponse.  The default value is 200.  \r\n\r\nThe bindings should be a key: value list for the view.  The keys\r\nshould map to variable names in your view.  \r\n\r\nThe conn is the conn record that was passed to your Controller\r\naction.  This is used in building and sending the response.  \r\n\r\nThe redirect function takes 2 arguments:  \r\n\r\n* status\r\n* conn\r\n\r\nThe status is the integer status code that should accompany the\r\nresponse.  The default is 302.  \r\n\r\nThe conn is the conn record that was passed to your Controller\r\naction.  This is used in building and sending the response.  \r\n\r\nThe forbidden function takes one argument:  \r\n\r\n* conn\r\n\r\nThe conn is the conn record that was passed to your Controller\r\naction.  This is used in building and sending the response.  \r\n\r\n### Views\r\n\r\n#### Organization\r\n\r\nViews in Charlotte are organized similarly to Views in Rails.\r\nThe view files for a controller are expected to be in a\r\nsubdirectory of the CHARLOTTE_VIEW_PATH with the same name as\r\nthe controller module that uses the view.  The actual view file\r\nis expected to have the same name as the controller action that\r\nrenders it.  \r\n\r\n```elixir\r\n  # Assuming a CHARLOTTE_VIEW_PATH of \"/var/www/app/views\"\r\n\r\n  $ ls -R /var/www/app/views\r\n    ./users:\r\n      show.ex\r\n      new.ex\r\n    ./fees:\r\n      list.ex\r\n    ./locations:\r\n      new.ex\r\n```\r\n\r\nThe above structure would result in the following code being\r\ngenerated:  \r\n\r\n* Charlotte.Views.Users\r\n  * show/1\r\n  * new/1\r\n* Charlotte.Views.Fees\r\n  * list/1\r\n* Charlotte.Views.Locations\r\n  * new/1  \r\n\r\nThese are public functions and can be called from any where at\r\nany time.  However the render function which is injected by the\r\nHTTP Handler will look them up and call the appropriate function.\r\n\r\n#### Content\r\n\r\nViews are rendered by EEx.  Any assigned variables should be\r\npreceeded by an @  \r\n\r\n```erb\r\n  Your name is <%= @name %>\r\n```\r\n\r\nWhen you are running your application in development views\r\nwill be read from the file each time they are called.  This\r\nmeans you don't need to restart the application to get\r\nchanges to existing views.  However Charlotte doesn't pick\r\nup new view files unless it is restarted.  This is due to the\r\nway the views are structured when compiled.  \r\n\r\nThere are plans to build a default URL that when requested will\r\ncause a recompile of all Views.  \r\n\r\nCharlotte currently doesn't have any helpers for link generation.\r\nThis is planned for the future.  \r\n\r\n### Configuration\r\n\r\nA brief word on configuration.  Charlotte is built to use a\r\n[12 Factor](http://12factor.net/config) approach to configuration.  \r\n\r\nWith this in mind the framework it's self expects a few\r\nconfiguration variables to be present:  \r\n\r\n* CHARLOTTE_CONTROLLER_PATH\r\n* CHARLOTTE_VIEW_PATH\r\n* CHARLOTTE_ASSET_PATH\r\n* CHARLOTTE_HOST\r\n* CHARLOTTE_PROTOCOL\r\n* CHARLOTTE_ACCEPTORS\r\n* CHARLOTTE_COMPRESS\r\n* CHARLOTTE_PORT  \r\n\r\nCharlotte uses [EnvConf](https://github.com/LeakyBucket/env_conf)\r\nto manage configuration settings, this also allows you to use the\r\nsame in your application without any additional setup.  \r\n\r\nIt is possible to send defaults when starting Charlotte from\r\nyour application module:  \r\n\r\n```elixir\r\n  default_config = HashDict.new\r\n\r\n  Charlotte.start [], [default_config: build_config(default_config)]\r\n\r\n  def build_config(default_config) do\r\n    default_config |>\r\n      HashDict.put(\"CHARLOTTE_CONTROLLER_PATH\", __DIR__ <> \"/support/controllers\") |>\r\n      HashDict.put(\"CHARLOTTE_VIEW_PATH\", __DIR__ <> \"/support/views\") |>\r\n      HashDict.put(\"CHARLOTTE_ASSET_PATH\", __DIR__ <> \"/support/assets\") |>\r\n      HashDict.put(\"CHARLOTTE_HOST\", \"localhost\") |>\r\n      HashDict.put(\"CHARLOTTE_PROTOCOL\", \"tcp\") |>\r\n      HashDict.put(\"CHARLOTTE_ACCEPTORS\", \"100\") |>\r\n      HashDict.put(\"CHARLOTTE_COMPRESS\", \"false\") |>\r\n      HashDict.put(\"CHARLOTTE_PORT\", \"8000\")\r\n  end\r\n```  \r\n\r\nYou can store/build these defaults however you wish.  All Charlotte\r\ncares about is that they are given as a HashDict.\r\n\r\nEnvConf will not overwrite any values that are already present in\r\nthe environment so it is safe to leave dev defaults in your code.\r\nThey won't overwrite configuration set in the environment directly\r\non a production system.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}